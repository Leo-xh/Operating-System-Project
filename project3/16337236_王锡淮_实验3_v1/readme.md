实验项目3
---
这是一个巨坑，我什么要弄这个32和16位兼容的问题。

### 需求分析
1. 建立一个表记录用户程序的存储安排
2. 查询用户查询的信息，信息包括程序名、字节数、磁盘位置、文件类型（文档、可执行、文件夹）。（定为ls指令，后面可以接名字）
    使用散列，名字作key。
3. 执行用户程序的指令（'./'+名字）
    详细方法是打一个名字将一个程序加载进内存，因为已经有了记录的表。
    而那些系统例程仍然开机就加载。
    用户程序有：

|name|size|lma|type|
|----|----|---|----|  
|os|8704|512|exec|
|loader|512|0|exec|
|system routine|2048|9216|exec|
|ball_A|512|18432|exec| 
|ball_B|512|18944|exec|
|ball_C|512|19456|exec|
|ball_D|512|19968|exec|
|printBigname|3072|20480|exec|
|fileRecord|1024|23552|document|
|manual.txt|3072|24576|document|
fileRecord要unix结尾


4. 显示时间（date）
5. 无错误提示
6. 重启（reboot）
7. 关机（exit）
8. 清空屏幕（clear）
9. 用户手册（man）
10. 滚屏

### version2 修改
记录放在硬盘上 ok

type指令 ok

history 放弃

加上上下左右按键 放弃

颜色 ok


### 问题表述

实验原理：
混合编译
x86调用约定
关机功能
日期
扇区的排列
内存的分配

### 使用GCC+NASM

想要使用gcc和nasm混合编译，首先了解二者的输出文件，nasm的默认输出是16位的程序，而gcc的默认输出是32位的程序，而我们知道编写32位的程序需要进入保护模式，但是本次实验要在实模式下完成，于是需要让最终的程序输出为16位程序。

工具链：sublime text 3 编写代码，nasm汇编.asm文件，gcc将编译进行到汇编这一步，ld完成最后的链接，以实现c和汇编语言混合编译，然后是bochs调试，以及最后的vmware进行展示。

实验环境：windows10系统

于是需要了解让gcc编译产生16位代码的方法，查看gcc的用户手册[gcc]发现了一些指令，
+ [-march]指令，可以指定机器类型，使用-march=i386 可以指定使用的是intel i386CPU指令体系。
+ [-m32]指令，该指令指示int，long还有指针类型的长度为32位，并且生成的程序在i386机器上运行。
+ [-mpreferred-stack-boundary=num] 该指令使栈4字节对齐，这样方便16位和32位的数据共存于栈。
+ [-ffreestanding]指令，由于我们编写出来的程序是要在只有bios的裸机上运行的，所以是没有任何库能够使用的，于是用该指令显示地指明这一点。
+ [-c]指令，该指令使得gcc在编译过程“预处理-编译-汇编-链接”中执行到汇编这一步，输出.o文件。

除了在使用gcc时的选项设置之外，还要在.c文件开头加上 __asm__(".code16gcc\n");语句，该语句中的__asm__是gcc中的基本汇编使用方法，而.code16gcc指示gcc在汇编这一步生成16位代码。（其实以上-m32选项和__asm__(".code16gcc\n");语句的功能等于-m16选项）。

那么nasm的选项如何设置呢？因为gcc的默认输出文件是elf格式的，所以nasm文件也应输出elf格式的32位文件。使用的是[-f elf32]选项。

除此之外，还要在每个汇编文件首部加上[BITS 16]指示nasm该汇编文件是16位的。在该模式下，使用32位数据指令会被加上0x66前缀，指向32位的地址也被加上0x67前缀。

而至于链接这一步，使用ld工具，查看用户手册可知:
+ [-m i386pe]指示ld目标机器是i386pe
+ [-N] 是让.data和.text段不对齐
+ [-Ttext]和[-Tdata]的功能相当于org指令

以上内容参考自一个[github项目](参考项目)。

在看这段描述的时候可能产生疑惑，就是为什么要在命令行里指示生成32位，然后又在代码文本里面设置生成16位代码呢？其原因是我们在编写汇编代码的时候习惯于使用16位的写法，而在编写c语言时许多变量又是32位的，为了兼容，以上操作使得代码变为在nasm中使用16位变量而在gcc中使用32位变量的16位程序。

详细用法可以看我的run.bat批处理文件。

### [X86调用约定][wikiX86]

GCC遵循cdecl（C declaration，即C声明）是C语言的一种调用约定，在X86架构上，其内容包括：
+ 函数实参在线程栈上按照从右至左的顺序依次压栈。
+ 函数结果保存在寄存器EAX/AX/AL中
+ 浮点型结果存放在寄存器ST0中
+ 编译后的函数名前缀以一个下划线字符
+ 调用者负责从线程栈中弹出实参（即清栈）
+ 8比特或者16比特长的整形实参提升为32比特长。
+ 受到函数调用影响的寄存器（volatile registers）：EAX, ECX, EDX, ST0 - ST7, ES, GS
+ 不受函数调用影响的寄存器： EBX, EBP, ESP, EDI, ESI, CS, DS
+ RET指令从函数被调用者返回到调用者（实质上是读取寄存器EBP所指的线程栈之处保存的函数返回 地址并加载到IP寄存器）

除了以上内容，通过观察反汇编结果可以发现，gcc编译出来的汇编代码在调用C语言编写的程序时的确遵循了上述约定。会在函数被调用者其流程为：
1. 将ebp压入栈中。
2. 将esp的值赋给ebp。
3. 减小esp，申请栈空间。
4. 将参数从右往左压入栈中。
5. 执行函数流程。
6. 将ebp的值弹出。
7. 将ebp的值赋给esp。
8. 返回调用者。

但是在调用汇编语言编写的程序时，gcc在调用者部分所做工作为：
1. 然后将函数从右向左压入栈中。
2. 随后用call指令调用函数。
 
并无保存ebp寄存器的值和恢复ebp寄存器的值的过程。所以在被调用的函数中自己注意维护栈，自己注意寻找返回地址的位置。

于是，如果要使用汇编编写C语言可以调用的函数，需要注意

1. 函数名添加下划线。
2. 返回值保存在eax中。
3. 注意栈中返回地址在哪个位置。
4. 要使用传递的参数，需要自行在栈中寻找，同时需要注意参数对应大小。

### [关机功能的实现](关机)

通过调用int 15h中断，首先关闭系统，再关闭驱动器，最后关闭全部进程。


更进一步？
----

算了我随手价格懒惰删除吧。。
+ 简单进程 尝试完成PCB和进程表（PS指令？）
进程表的表项就是PCB，存储的是各寄存器和retaddr（所去的地址），以及当前的地址和栈帧
要实现这一点，程序里面的变量就要放在PCB栈里，注意栈的切换。
切换入进程：

切换入内核：

再入进程：

+ 中断 不了不了
+ 简单文件系统 真的“简单”？加上type,rm指令？[参考](https://www.zhihu.com/question/37550565) 
不能malloc，只能用静态的了。

+ 设想：跨段跳转
+ 设想：挂起态和就绪态

+ 设想：鼠标接入上下滚动。
+ 设想：左右上下方向键

心情记录/琐碎
-----

bin太大怎么办

系统界面设计-进程-系统-文件信息-用户程序

中断获取日期

每个c文件都要添加__asm__(".code16gcc\n");

x86函数调用约定，在函数内部不要使用ebp（包括bp）
只有gcc编译出来的会这样，nasm出来的不会，要模拟。
nasm的调用是只会压栈，不会记录ebp

不能调用GCC标准库

栈的初始化

函数内部变量记得初始化

返回的eax清空前部，否则越界

关机程序

给予进程的内核模型

gcc的汇编变量类型和数据分离

没想到我用了超过一个磁道（柱面），扇区的排列
内存的分配要注意

垃圾滚屏，我错了，是我误会你了



神仙bug，全局变量定义多了，会覆盖0xc800后面的内容。





[内存分布](内存分布)

[程序分段](程序分段)

[程序分段](https://zhuanlan.zhihu.com/p/28659560)
[内存分布](https://github.com/Urinx/SomeCodes/tree/master/Asm/Boot)
[gcc](https://gcc.gnu.org/onlinedocs/gcc-5.5.0/gcc/x86-Options.html#x86-Options)
[参考项目](https://github.com/richardtsai/homework)
[wikiX86]:[https://zh.wikipedia.org/wiki/X86%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A#cdecl]
[关机](https://blog.csdn.net/wbcuc/article/details/7873314)