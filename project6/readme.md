## Project 6

### 进一步的进程模型

- [ ] 实现六态模型（加入挂起态）
- [x] 有个bug，blocked的时候没有将剩余的save起来
        通过逐个block的方法解决了。
- [ ] 堆中分配空间
- [ ] 挂起态
- [ ] 多级文件系统

正常实验要求
1. do_fork原语和fork调用
    其实是产生线程，因为只复制堆栈和pcb，共享代码段和全局数据段，注意的是将返回值：（PID/-1）放在父进程的ax，（0）放在子进程ax；还要注意在进程表项中加入父进程指针。
2. do_exit原语和exit(int exit_value)调用
    返回值传递给父进程（wait的那个参数），所以需要一个表项变量指向这个地址；恢复阻塞进程。
3. do_wait原语和wait(&exit_value)调用
    wait也就是阻塞当前进程，等待子进程，实现方法可以是维护队列，每个进程保存等待的事件（进程号），当事件退出时转为就绪态。记录返回值位置。
4. wakeup原语
5. blocked原语

改实现，实现就绪队列、挂起队列、阻塞队列。

创建进程时，加入就绪队列；
进程调度从就绪队列中拿出一个进程ID，若不存在，则返回内核；
对于用户程序，按下退出键后阻塞自己，然后继续调度；
wakeup函数也只是wakeup一个进程，然后继续调度；
进程退出时，观察阻塞队列中有没有正在等待自己的进程，有则将其加入就绪队列，
    还要将返回值放在指定位置并修改父进程的子进程序号以通知父进程。


### traps
+ esp,ebp默认用ss
+ 又是这种问题，记住好像save那样保存sp的时候保存的是真正的“应当用”的栈，比如save中有三个栈单元已经用了。
+ 不要随便使用pusha
+ mmp,restart忘了恢复ss到内核栈，改了代码段
+ 加入队列后调度十分复杂，比如状态转换时要注意当前状态是什么
+ int21h fork的时候，要存两份iret返回需要的信息，因为有一份会被用掉；
    另外，memcpy和createprocess的顺序要注意。
+ 垃圾优先级
+ 注意返回值和pop ax
+ 不用地址。
+ 局部变量不能用到地址。
+ 框架下的限制，不能在同一个程序中使用两个数据段的数据（通过地址），解决不了，只能放弃使用地址。
+ 硬编码错误，，，