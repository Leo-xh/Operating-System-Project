### 关于进程

#### 进程的表示
操作系统维护着四种不同类型的表：

1. 内存表：

    必须包含以下信息：

    - 分配给进程的内存
    - 管理内存所需的信息
    
    设计如下：
    是一个数组，数组元素是结构体，记录分区的起始位置和大小。

2. I/O表：

3. 文件表：

4. 进程表：

    包含以下信息：

    - 进程映像（用户数据、程序、系统栈、pcb）的位置
    - 进程属性（PCB）
        + 标识符
        + 进程状态
        + [ ] 优先级
        + 控制信息

#### 进程控制

1. 进程创建：
    + 分配唯一的进程标识符
        在主进程表中加入一个新表项，顺序赋值得了。
    + 分配空间
        包括进程映像中的所有元素，可以使用默认值，但是想用程序大小（起始由于没有动态内存分配，实际上已经包含了数据部分）加上1k的栈。
    + 初始化进程控制块
        除了程序计数器、代码段地址、用户栈段地址、用户栈指针，其余信息一般初始化为0。
    + 连接
        放入相应状态调度队列中，这里就一个。
        
2. 进程切换（在操作系统从当前正在运行的进程中获得控制权的任何时刻发生）：
    + 先切换进内核态，因为进程切换属于特权操作
    + 调用分配器（调度函数）
    + 过程
        * 保存上下文
        * 更新进程控制块，比如状态等
        * 移入相应调度队列
        * 选择一个要执行的进程
        * 更新该进程控制块，包括状态变为运行态


- [ ] 3. 进程挂起，这就需要文件系统了。

#### 内存管理
设计如下：

+ 动态分区
    拿出一个段（1000段，容量64K）作为可分配内存，使用首次匹配放置算法。
+ 重定向

#### 调度管理
+ 长程调度
不考虑，所有程序进入系统中处理。
+ 中程调度
目前没有挂起态，没有中程调度的位置。
+ 短程调度
Round Rodin。

### References
[X86汇编各种操作，wiki](https://en.wikibooks.org/w/index.php?title=X86_Assembly&stable=1)


### 碎碎念
-----
终于找了我的疑惑在哪：
对于现在学的操作系统概念（单道、多道、分时）都是已经提供好了作业序列，即使是分时系统（其有多个作业序列），所以我的操作系统不能动态加入进程是正常的。

所以在这次实验中使用的方法应当是在命令行里面加入一批作业名称，然后一起执行。

- [X]批处理交互运行

六态模型
- [X]实现阻塞态

- [X]阻塞态转就绪态

- [ ]挂起态

- [ ]多级文件系统

#### traps
sizeofProcess
改ss坑我
改curprocessId
调用原int 8h?
保留的不一定是cs,可能是中断位置
别开优化.
调用c函数ds
cli
save注意sp改回去

